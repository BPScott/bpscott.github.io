<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible> <title>Bower vs. npm for packaging Sass | Reload.me.uk</title> <meta name=viewport content="width=device-width, initial-scale=1"> <link href='https://fonts.googleapis.com/css?family=Noto+Serif' rel=stylesheet> <link href="/stylesheets/all.css" rel=stylesheet /> <link rel=alternate type="application/atom+xml" title="Reload.me.uk - feed" href="http://feeds.feedburner.com/reloadmeuk"/> <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-4167857-1', 'auto');
      ga('send', 'pageview');
    </script> </head> <body class="x2014 x2014_bower-vs-npm-for-packaging-sass x2014_bower-vs-npm-for-packaging-sass_index"> <div class=page-wrapper> <header class=page-header> <div class=header-title> <h1><a href="/">Reload.me.uk</a></h1> </div> <div class=header-nav> <ul class="nav nav--global"> <li><a href="/">Words</a></li> <li><a href="/about/">About</a></li> </ul> </div> </header> <div class=page-content> <article class="article article--full"> <header> <h1 class=article__title>Bower vs. npm for packaging Sass</h1> <p class=article__meta> Posted on <time datetime=2014-08-01>Aug 1 2014</time> </p> </header> <p>Package managers for the front end. Fun eh? I&#39;m about to be playing with creating a modular CSS framework that needs to be shared across applications, so I figured now would be a good time to investigate the tools available. As nobody else seems to have done this with a specific eye to CSS I might as well write about it too. Here is my use-case:</p> <ul> <li>I&#39;m building a CSS framework, written in Sass (though this investigation&#39;s outcome would apply to all CSS preprocessors).</li> <li>I&#39;ll have some fundamental mixins and functions, which shall be used by multiple components, these components shall then be included into my application.</li> <li>My build pipeline shall be using Grunt.</li> </ul> <p>There are two package managers on my shortlist: npm and Bower. Both are generic package managers. Both make you specify your dependencies in json files. Both install their dependencies into a folder within your application. At first glance they are very similar and my initial gut feeling was &ldquo;if I&#39;m already using npm for Grunt then why do I need Bower?&rdquo;. Why complicate the project with an additional package manager? There must be something I&#39;m missing.</p> <p>The key difference between the two lies in <a href="http://stackoverflow.com/questions/18641899/difference-between-bower-and-npm/18652918#18652918">how they store dependent packages</a>. Bower has a flat listing, while npm uses a nested hierarchy. To demonstrate this difference lets use a couple of hypothetically named packages, that map neatly onto a real world example used by the Guardian:</p> <ul> <li>Application - your app (e.g. The Guardian website) - which depends on:</li> <li>Component - a generic reusable CSS object (e.g. <a href="https://github.com/guardian/guss-layout">guss-layout</a>) - which depends on:</li> <li>Helper - a selection of utility Sass mixins / functions (e.g. <a href="https://github.com/guardian/sass-mq">sass-mq</a>)</li> </ul> <p>This is a drastically simplified example with a single component and helper, but think about how this can expand when there is multiple component packages each depending on various helper packages.</p> <h2>Bower&#39;s flat listing</h2> <p>Bower flattens your dependency graph and installs all dependencies at the same level, so after running <code>bower install</code> the application folder would like this:</p> <div class=highlight><pre class="highlight plaintext"><code>|--- bower_components
|    |--- component
|    |    |--- _component.scss
|    |--- helper
|    |    |--- _helper.scss
|--- bower.json
|--- styles.scss
</code></pre></div> <p>This is really simple, but it can potentially pose a major problem - dependency hell, which can occur when multiple components rely on different versions of the same helper. Because Bower does not allow installing two versions of the same package everything grinds to a halt.</p> <p>Bower&#39;s flat listing means that the path to all of the app&#39;s dependencies are one level deep so the app&#39;s <code>styles.css</code> would look like this:</p> <div class=highlight><pre class="highlight scss"><code><span class="k">@import</span> <span class="s1">'bower_components/helper/helper'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s1">'bower_components/compoent/component'</span><span class="p">;</span>
</code></pre></div> <p>This can be tidied up by adding <code>bower_components</code> to the Sass load_path to save repeating it every time:</p> <div class=highlight><pre class="highlight scss"><code><span class="k">@import</span> <span class="s1">'helper/helper'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s1">'compoent/component'</span><span class="p">;</span>
</code></pre></div> <p>Very neat and tidy.</p> <h2>Npm&#39;s dependency tree</h2> <p>Npm keeps the dependency tree intact, installing each package&#39;s dependencies into a <code>node_modules</code> folder within that package, so after running <code>npm install</code> the application folder would look like this:</p> <div class=highlight><pre class="highlight plaintext"><code>|--- node_modules
|    |--- component
|    |    |--- _component.scss
|    |    |--- node_modules
|    |    |    |--- helper
|    |    |    |    |--- _helper.scss
|--- package.json
|--- styles.scss
</code></pre></div> <p>This layout is a bit more complex than Bower&#39;s flat listing, but it avoids dependency hell as each component is responsible for its own dependencies rather than having them all merged into the same level.</p> <p>This nested dependency graph means the app&#39;s stylesheet&#39;s <code>@imports</code> end up looking a little uglier than the Bower version:</p> <div class=highlight><pre class="highlight scss"><code><span class="k">@import</span> <span class="s1">'node_modules/component/node_modules/helper/helper'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s1">'node_modules/compoent/component'</span><span class="p">;</span>
</code></pre></div> <p>All this nesting means there isn&#39;t much value in adding <code>node_modules</code> to the load path as there is still a load of node_modules references at lower levels littering the <code>@import</code> paths anyway.</p> <h2>Unavoidable Dependency Hell</h2> <p>The thing is though, npm&#39;s resolution to dependency hell works great for JS modules where you can scope the inclusion of a particular version of a helper to a particular component. Sass has no such scoping though. You can only import files into the global scope which means that any mixins and functions contained within them also live in the global scope. Sass does not complain about overwriting an existing mixin or function, which can lead to subtle and insidious bugs when one version of a helper overwrites a different one and gets used within a component that does not support it.</p> <p>It&#39;s a potential minefield and I can&#39;t come up with a way out of this mismatched dependency thing in Sass other than being careful not to fall prey to it in the first place. Which can be done by being careful about not breaking backwards compatibility in your helper&#39;s API, or when you do inevitably break it, you have to upgrade everything that depends on that helper all at the same time. It&#39;s a sucky problem but really your helpers should be so simple that you will not need to update them in a way that breaks prior expectations anyway. As the old joke goes: &ldquo;Doctor doctor, it hurts when I do <strong>this</strong>&rdquo; &ldquo;Well, don&#39;t do it then&rdquo;. Not got a better solution that the utterly unhelpful &ldquo;you just need to <strong>know</strong> when you&#39;re about to do it wrong&rdquo;, sorry.</p> <p>So, npm&#39;s nested dependency tree is not actually a feature that is relevant to writing a Sass framework anyway as Sass does not support that sort of scoping. Which means that Bower is looking a lot nicer due to its simpler folder structure (as npm&#39;s apparent complexity does not help solve anything in Sass-land) and its ability to give bit of sugar around load paths. Balls, this wasn&#39;t the answer I was hoping for, I don&#39;t want to require a second package manager. What if I can make npm use a flat folder structure like Bower?</p> <h2>NPM Peer Dependencies</h2> <p>What if I fiddle with that dependency graph a little bit. What if I say that a component should not be responsible for loading in the helpers it needs, but instead should trust that the application has already loaded a compatible version of the helper that is available for the component to use. It means your components break if you do not include that helper in your application&#39;s scss file but it seems like a small price to pay for ensuring you are only pulling in a single version of your helpers. It sounds daft and horrible but it might get us out of this.</p> <p>Here is the revised dependency chain, where the application explicitly states that it requires Component and Helper, and Component hints that it needs a specific version of Helper:</p> <ul> <li>Application - your app (e.g. The Guardian website) - which depends on: <ul> <li>Component (hinted: I need Helper to be included before me)</li> <li>Helper</li> </ul></li> </ul> <p>NPM has support for this hinting of things a component needs, but never calls directly as a feature called <a href="http://blog.nodejs.org/2013/02/07/peer-dependencies/">peer dependencies</a>. By specifying the helper as a peer dependency npm shall throw a error if two components attempt to rely on two different versions of a single helper.</p> <p>The component&#39;s <code>package.json</code> would look like:</p> <div class=highlight><pre class="highlight javascript"><code><span class="p">{</span>
  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"component"</span><span class="p">,</span>
  <span class="s2">"version"</span><span class="p">:</span> <span class="s2">"1.0.0"</span><span class="p">,</span>
  <span class="s2">"dependencies"</span><span class="p">:</span> <span class="p">{},</span>
  <span class="s2">"devDependencies"</span><span class="p">:</span> <span class="p">{},</span>
  <span class="s2">"peerDependencies"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"helper"</span><span class="p">:</span> <span class="s2">"~1.0.0"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>The app&#39;s <code>package.json</code> would look like this:</p> <div class=highlight><pre class="highlight javascript"><code><span class="p">{</span>
  <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"myApp"</span><span class="p">,</span>
  <span class="s2">"dependencies"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">"helper"</span><span class="p">:</span> <span class="s2">"~1.0.0"</span><span class="p">,</span>
    <span class="s2">"component"</span><span class="p">:</span> <span class="s2">"~1.0.0"</span>
  <span class="p">},</span>
  <span class="s2">"devDependencies"</span><span class="p">:</span> <span class="p">{},</span>
  <span class="s2">"peerDependencies"</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div> <p>When you run <code>npm install</code> in your application&#39;s tree shall look like:</p> <div class=highlight><pre class="highlight plaintext"><code>|--- node_modules
|    |--- component
|    |    |--- _component.scss
|    |--- helper
|    |    |--- _helper.scss
|--- package.json
|--- styles.scss
</code></pre></div> <p>And thus your app&#39;s stylesheet would look like:</p> <div class=highlight><pre class="highlight scss"><code><span class="k">@import</span> <span class="s1">'node_modules/helper/helper'</span><span class="p">;</span>
<span class="k">@import</span> <span class="s1">'node_modules/compoent/component'</span><span class="p">;</span>
</code></pre></div> <p>Currently peer dependencies are installed automatically and npm throws an error when packages want to install conflicting versions of a peer dependency, so we don&#39;t really need to explicitly specify them in the application&#39;s package.json. However the npm maintainers <a href="https://github.com/npm/npm/issues/5080#issuecomment-40771461">don&#39;t like the idea of peer dependencies in this form</a>. They would rather change it so that peerDependencies are not installed automatically and that npm would warn rather than error when there are peer dependency conflicts. I would rather be a bit more explicit in the application&#39;s package.json to be ready for that impending change. So now we have that flat Bower-like layout that we were hoping for, at the expense of having to write a little more in our package.json manifest file. I&#39;m pretty happy with that.</p> <h2>Conclusion</h2> <p>The more I sit and thing about this, the more I think that using npm with peerDependencies is a good idea. It is not <strong>explicitly</strong> what peerDependencies was originally envisioned for, but I think it seems like a good ideological fit and certainly appears to solve the problem - while keeping build-time complexity down thanks to not needing the overhead of Bower. <a href="https://twitter.com/BPScott">Please tell me if I&#39;m crazy</a>.</p> </article> </div> <footer class=page-footer> </footer> </div> <div class=page-footer-outer> <p class=copy-info> &copy; Ben Scott 2018. @BPScott on <a href="https://twitter.com/BPScott">Twitter</a> and <a href="https://github.com/BPScott">GitHub</a>. </p> </div> </body> </html>